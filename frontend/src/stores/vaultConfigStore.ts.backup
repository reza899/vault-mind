import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { VaultConfig, IndexingSchedule } from '@/types';

interface ValidationError {
  field: string;
  message: string;
}

interface AdvancedConfig {
  chunk_size: number;
  chunk_overlap: number;
  embedding_model: string;
  ignore_patterns: string[];
  file_types: string[];
  max_file_size_mb: number;
  parallel_processing?: boolean;
  batch_size?: number;
  custom_metadata?: Record<string, unknown>;
}

interface VaultConfigState {
  // Current configuration
  currentConfig: Partial<VaultConfig>;
  
  // Form state
  isFormDirty: boolean;
  isSubmitting: boolean;
  
  // Validation
  validationErrors: ValidationError[];
  touchedFields: string[];
  
  // Recent configurations
  recentConfigs: VaultConfig[];
  
  // Actions
  updateConfig: (updates: Partial<VaultConfig>) => void;
  setFieldTouched: (field: string) => void;
  validateConfig: (config: VaultConfig) => ValidationError[];
  getValidationErrors: () => ValidationError[];
  clearValidation: () => void;
  resetForm: () => void;
  saveConfig: (config: VaultConfig) => void;
  loadConfig: (config: VaultConfig) => void;
  deleteRecentConfig: (configId: string) => void;
  setSubmitting: (submitting: boolean) => void;
}

// Default configurations
const defaultAdvancedConfig: AdvancedConfig = {
  chunk_size: 1000,
  chunk_overlap: 200,
  embedding_model: 'all-MiniLM-L6-v2',
  ignore_patterns: ['.obsidian/**', '.trash/**', 'templates/**'],
  file_types: ['.md', '.txt'],
  max_file_size_mb: 10,
  parallel_processing: true,
  batch_size: 10,
};

const defaultSchedule: IndexingSchedule = {
  enabled: false,
  frequency: 'manual',
  time: '02:00',
  timezone: 'America/New_York',
};

// Validation rules
const validateVaultName = (name: string): string | null => {
  if (!name || name.trim().length === 0) {
    return 'Vault name is required';
  }
  if (name.trim().length < 2) {
    return 'Vault name must be at least 2 characters';
  }
  if (name.trim().length > 50) {
    return 'Vault name must be less than 50 characters';
  }
  if (!/^[a-zA-Z0-9\s\-_]+$/.test(name.trim())) {
    return 'Vault name can only contain letters, numbers, spaces, hyphens, and underscores';
  }
  return null;
};

const validateVaultPath = (path: string): string | null => {
  if (!path || path.trim().length === 0) {
    return 'Vault path is required';
  }
  if (!path.startsWith('/')) {
    return 'Vault path must be an absolute path';
  }
  if (path.includes('..')) {
    return 'Vault path cannot contain relative path segments';
  }
  return null;
};

const validateAdvancedConfig = (config: AdvancedConfig): ValidationError[] => {
  const errors: ValidationError[] = [];

  if (config.chunk_size < 100 || config.chunk_size > 4000) {
    errors.push({
      field: 'chunk_size',
      message: 'Chunk size must be between 100 and 4000 tokens'
    });
  }

  if (config.chunk_overlap < 0 || config.chunk_overlap >= config.chunk_size) {
    errors.push({
      field: 'chunk_overlap',
      message: 'Chunk overlap must be between 0 and chunk size'
    });
  }

  if (config.max_file_size_mb < 1 || config.max_file_size_mb > 100) {
    errors.push({
      field: 'max_file_size_mb',
      message: 'Max file size must be between 1 and 100 MB'
    });
  }

  if (!config.embedding_model || config.embedding_model.trim().length === 0) {
    errors.push({
      field: 'embedding_model',
      message: 'Embedding model is required'
    });
  }

  if (config.file_types.length === 0) {
    errors.push({
      field: 'file_types',
      message: 'At least one file type must be specified'
    });
  }

  return errors;
};

const validateSchedule = (schedule: IndexingSchedule): ValidationError[] => {
  const errors: ValidationError[] = [];

  if (schedule.enabled && schedule.frequency !== 'manual') {
    switch (schedule.frequency) {
      case 'hourly':
        if (!schedule.interval || schedule.interval < 1 || schedule.interval > 24) {
          errors.push({
            field: 'schedule.interval',
            message: 'Hourly interval must be between 1 and 24 hours'
          });
        }
        break;
      
      case 'daily':
      case 'weekly':
        if (!schedule.time || !/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(schedule.time)) {
          errors.push({
            field: 'schedule.time',
            message: 'Time must be in HH:MM format'
          });
        }
        if (schedule.frequency === 'weekly') {
          if (!schedule.days_of_week || schedule.days_of_week.length === 0) {
            errors.push({
              field: 'schedule.days_of_week',
              message: 'At least one day must be selected for weekly schedule'
            });
          }
        }
        break;
      
      case 'custom':
        if (!schedule.cron_expression || schedule.cron_expression.trim().length === 0) {
          errors.push({
            field: 'schedule.cron_expression',
            message: 'Cron expression is required for custom schedule'
          });
        } else {
          // Basic cron validation (5 parts)
          const parts = schedule.cron_expression.trim().split(/\s+/);
          if (parts.length !== 5) {
            errors.push({
              field: 'schedule.cron_expression',
              message: 'Cron expression must have 5 parts: minute hour day month day-of-week'
            });
          }
        }
        break;
    }
  }

  return errors;
};

export const useVaultConfigStore = create<VaultConfigState>()(
  persist(
    (set, get) => ({
      // Initial state
      currentConfig: {
        vault_name: '',
        vault_path: '',
        description: '',
        schedule: defaultSchedule,
        advanced: defaultAdvancedConfig,
      },
      isFormDirty: false,
      isSubmitting: false,
      validationErrors: [],
      touchedFields: [],
      recentConfigs: [],

      // Actions
      updateConfig: (updates) => {
        set((state) => ({
          currentConfig: { ...state.currentConfig, ...updates },
          isFormDirty: true,
        }));
        
        // Re-validate after update
        const { validateConfig } = get();
        const newConfig = { ...get().currentConfig, ...updates } as VaultConfig;
        if (newConfig.vault_name && newConfig.vault_path) {
          const errors = validateConfig(newConfig);
          set({ validationErrors: errors });
        }
      },

      setFieldTouched: (field) => {
        set((state) => ({
          touchedFields: state.touchedFields.includes(field) 
            ? state.touchedFields 
            : [...state.touchedFields, field],
        }));
      },

      validateConfig: (config) => {
        const errors: ValidationError[] = [];

        // Validate basic fields
        const nameError = validateVaultName(config.vault_name);
        if (nameError) {
          errors.push({ field: 'vault_name', message: nameError });
        }

        const pathError = validateVaultPath(config.vault_path);
        if (pathError) {
          errors.push({ field: 'vault_path', message: pathError });
        }

        // Validate advanced config
        if (config.advanced) {
          errors.push(...validateAdvancedConfig(config.advanced));
        }

        // Validate schedule
        if (config.schedule) {
          errors.push(...validateSchedule(config.schedule));
        }

        set({ validationErrors: errors });
        return errors;
      },

      getValidationErrors: () => {
        return get().validationErrors;
      },

      clearValidation: () => {
        set({ validationErrors: [], touchedFields: [] });
      },

      resetForm: () => {
        set({
          currentConfig: {
            vault_name: '',
            vault_path: '',
            description: '',
            schedule: defaultSchedule,
            advanced: defaultAdvancedConfig,
          },
          isFormDirty: false,
          isSubmitting: false,
          validationErrors: [],
          touchedFields: [],
        });
      },

      saveConfig: (config) => {
        const configWithId = {
          ...config,
          id: `config_${Date.now()}`,
          created_at: new Date().toISOString(),
        };

        set((state) => ({
          recentConfigs: [
            configWithId,
            ...state.recentConfigs.filter(c => c.vault_name !== config.vault_name).slice(0, 9)
          ],
          isFormDirty: false,
        }));
      },

      loadConfig: (config) => {
        set({
          currentConfig: {
            vault_name: config.vault_name,
            vault_path: config.vault_path,
            description: config.description || '',
            schedule: config.schedule || defaultSchedule,
            advanced: config.advanced || defaultAdvancedConfig,
          },
          isFormDirty: false,
          validationErrors: [],
          touchedFields: [],
        });
      },

      deleteRecentConfig: (configId) => {
        set((state) => ({
          recentConfigs: state.recentConfigs.filter(c => (c as any).id !== configId),
        }));
      },

      setSubmitting: (submitting) => {
        set({ isSubmitting: submitting });
      },
    }),
    {
      name: 'vault-config-store',
      // Only persist certain fields
      partialize: (state) => ({
        recentConfigs: state.recentConfigs,
      }),
    }
  )
);

// Helper hooks for common use cases
export const useVaultConfigValidation = () => {
  const { validationErrors, touchedFields, setFieldTouched } = useVaultConfigStore();
  
  const getFieldError = (field: string): string | undefined => {
    if (!touchedFields.has(field)) return undefined;
    return validationErrors.find(err => err.field === field)?.message;
  };

  const hasFieldError = (field: string): boolean => {
    return Boolean(getFieldError(field));
  };

  const isFieldValid = (field: string): boolean => {
    return touchedFields.has(field) && !hasFieldError(field);
  };

  return {
    validationErrors,
    touchedFields,
    getFieldError,
    hasFieldError,
    isFieldValid,
    setFieldTouched,
  };
};

export const useFormState = () => {
  const { isFormDirty, isSubmitting, setSubmitting } = useVaultConfigStore();
  
  return {
    isFormDirty,
    isSubmitting,
    setSubmitting,
  };
};